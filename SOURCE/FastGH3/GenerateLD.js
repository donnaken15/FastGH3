
// smaller (maybe) alternative to
// resources because .NET is absurd
// abusing the soy compilation rule
// of all strings being UTF 16 LE

const fs = require('fs');

const classname = "Launcher";
const reslist = {
	T: {
		// launcher strings
		// next step in autism, compress with LZSS and huffman
		// maybe pointless if i'm already using mpress
		binary: false,
		ascii: true,
		escaped: true,
		splitter: '\n',
		source: "lt.txt"
	},
	cr: {	// credits text, for those who even care
		binary: false,
		ascii: true,
		escaped: false,
		source: "credits.txt"
	},
	kl: {	// keybind list
		binary: true,
		source: "kl.bin"
	},
	qn: {	// new qb
		binary: true,
		source: "qn.bin"
	},
	pn: {	// new pak
		binary: true,
		source: "pn.bin"
	},
	fsbdat: { // modern day hed
		binary: true,
		source: "dat.bin"
	},
	fsbdat07: { // uh oh
		binary: true,
		source: "dat_0.7.bin"
	},
	defscn: {
		binary: true,
		source: "def.scn",
		raw: true
	},
	xmlDefault: {
		ascii: true,
		string: `<?xml version="1.0" encoding="utf-8"?>
<r>
<s id="Video.Width">1024</s>
<s id="Video.Height">768</s>
<s id="Sound.SongSkew">-0.1</s>
</r>`
	},
	splashText: {
		ascii: true,
		string: `
 Welcome to FastGH3 v1.0

 FastGH3 is an advanced mod of
 Guitar Hero 3. With this mod, you
 can play customs without any technical
 setup, and even associate chart or mid
 files with the game so you can access
 your charts quickly.

 To access the options, use
 the -settings parameter or
 open settings.bat.

 Press any key to load a chart.`
	},
	TT: {
		ascii: false,
		splitter: '\n',
		string:
			"FASTGH3 BACKGROUND PREVIEW™©®\n" +
			""
	},
	sctn: {
		ascii: true, // fix plain unicode string output
		splitter: '\n',
		source: "sctn.txt"
	},
	gsn: {
		ascii: true,
		ignore_empty: true,
		//skip_dupes: true,
		splitter: '\n',
		source: "gsn.txt"
	} // should rather be stored as a precalculated qbkey list if I can even make that work like ExtendCRC somehow.
	// including WT--, RB games in the slight nonzero chance that someone converted them for GH3/Aero/GHTCP
};
const escs = {'n': '\n', 'r': '\r', 't': '\t'};
function parse_esc(part)
{
	var i = 0;
	var res = "";
	if (part.length == 3)
		res = part[i++];
	var repl = escs[part[++i]];
	res += (repl === undefined ? part[i] : repl);
	return res;
}
// this thing only exists in C# (brow raise emoji)

var output = // header
`\ufeff// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// THIS FILE IS AUTOGENERATED BY GenerateLD.js
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// cannot be compiled with #develop because
// it for some reason errors on reading
// a null character when compiling
using System;
using System.Text;
static partial class Launcher
{
	static Encoding A = Encoding.ASCII;
	static Encoding U = Encoding.Unicode;
`;
for (var R in reslist) {
	const res = reslist[R];
	var direct_string = res.hasOwnProperty("string");
	var buf = !direct_string ? fs.readFileSync('res/'+res.source) : res.string;
	if (buf.length % 2 === 1)
	{
		if (direct_string)
			buf += '\0';
		else
			buf = Buffer.concat([buf, Buffer(1)]);
	}
	const sep = "~";
	var string;
	var data_type;
	var raw_string = null;
	var string_array = res.binary !== true && res.splitter !== undefined;
	// don't know if this === undefined can also return condition as false
	if (res.binary === true && !direct_string)
	{
		//console.log(res.source);
		if (res.raw !== true)
			string = buf.toString('ucs2');
		else
			string = new Uint8Array(buf).toString();
		//fs.writeFileSync('test.txt', string, {encoding: 'utf8'});
		//console.log(string);
		data_type = "byte[]";
	}
	else
	{
		string = buf.toString();
		data_type = "string";
		if (string_array)
		{
			string = string.replace(new RegExp(res.splitter, 'g'), sep);
			data_type += "[]";
		}
		if (res.escaped)
		//	string = string.replaceAll('\\\\\\n', '\\\n') // hate
		//					.replaceAll('\\\\n', '\\\n')
		//					.replaceAll('\\n', '\n')
		//					.replaceAll('\\\\\\', '\\\\')
		//					.replaceAll('\\\\', '\\');
			string = string.replace(/([^\\\n])?\\./g, parse_esc);
		if (string_array)
			raw_string = string.split(sep);
		else
			raw_string = string;
		//fs.writeFileSync('test.txt',
		//	Buffer(string+'\0\0').toString(res.ascii ? 'utf16le' : 'utf8'),
		//	{encoding: 'utf16le'});
		string = Buffer(string).toString(res.ascii === true ? 'utf16le' : 'utf8');
		//fs.writeFileSync('test.txt', string, {encoding: 'utf8'});
	}
	string = string
		.replace(/\n/g,'n')
		.replace(/\r/g,'r')
		.replace(/\\/g, '\\\\')
		.replace(/"/g, '\\"')
		.replace(/\u2027/g, '\\u2027') // wtf are these chars
		.replace(/\u2028/g, '\\u2028')
		.replace(/\u2029/g, '\\u2029')
		//.replace(/\ude30/g, '\\ude30')
		//.replace(/\udb68/g, '\\udb68')
		//.replace(/\uddca/g, '\\uddca') // need a function for this
		//.replace(/\udd27/g, '\\udd27') // if this entire range is like this
		//.replace(/\udbeb/g, '\\udbeb') // doesnt correct the problem i had
		//.replace(/\udb03/g, '\\udb03')
		//.replace(/[\uaa00-\uffff]/g,(e) => '\\u'+e.charCodeAt(0).toString(16))
		.replace(/\u0000/g, '\\0')
		.replace(//g,'\\u0085') // wtf is this, causes newline
		;
		//.replaceAll(/[\x80-\x8F]/g,());
	output += '\tpublic static readonly '+(data_type)+" "+R+" = ";
	// MESSSSSSSSSSSSSSSSSSSSSS
	var dontConvert = !(res.binary === true || (res.ascii === true && res.binary !== true));
	dontConvert = (!dontConvert && (res.raw === true && !direct_string)); // my head hurts
	dontConvert = (!dontConvert && !(res.ascii === true || res.binary === true)); // my head hurts
	if (res.binary === true || res.ascii === true || direct_string)
	{
		if (res.ascii === true)
			output += "A.GetString(\n\t\t";
		//console.log(res);
		if (res.binary === true && res.raw === true)
			output += "new byte[] {";
		else if (!dontConvert)
			output += "U.GetBytes(";
		if (raw_string !== null)
		{
			if (!string_array)
			{
				output += "\n\t\t// " +
					raw_string
						.replace('\0', '')
						.replace(/\r/g, '')
						.replace(/\n/g, '\n\t\t// ') + '\n\t\t#region';
			}
			else
			{
				output += '\n';
				var j = 0;
				for (var i = 0; i < raw_string.length; i++)
				{
					if (raw_string[i] === '')
						continue;
					if (i > 0)
						output += '\n';
					output += "\t\t// ["+(j++)+"]\n\t\t// " +
						raw_string[i]
							.replace('\0', '')
							.replace(/\r/g, '')
							.replace(/\n/g, '\n\t\t// ');
				}
				output += '\n\t\t#region';
			}
			output += '\n\t\t"'+string+'"\n';
		}
		else
		{
			output += '\n\t\t#region\n\t\t';
			if (res.raw === true && res.binary === true)
				output += string;
			else
				output += '"'+string+'"';
		}
		if (res.ascii !== true)
			output += '\n';
		output += '\t\t#endregion';
		//if (res.ascii !== true)
			output += '\n';
		if (res.ascii === true)
			output += "\t\t)\n";
		output += '\t';
		if (res.raw === true && res.binary === true)
			output += '}';
		else if (!dontConvert)
			output += ')';
		if (string_array)
			output += '.Split(new char[] {\''+sep+'\'}' + (res.ignore_empty === true ? ', StringSplitOptions.RemoveEmptyEntries' : '') + ')';
		output += ';\n';
	}
}
output += '}';
fs.writeFileSync('LD.cs', output, {encoding: 'utf8'});
